
# from flask import Flask, render_template, request, redirect, url_for
# import os
# from gen_htp import Gen_HTP  # Import the Gen_HTP function

# app = Flask(__name__)

# @app.route('/')
# def index():
#     return render_template('index.html')

# @app.route('/generate', methods=['POST'])
# def generate():
#     # Retrieve form data
#     slice_height = float(request.form['slice_height'])
#     segm_length = float(request.form['segm_length'])
#     store_path = request.form['store_path']

#     # Mock data for `mvFeatureData` (replace with actual data structure)
#     mvFeatureData = []  # Placeholder; add your shape data here

#     # Generate HTP using the provided parameters
#     Gen_HTP(slice_height, segm_length, mvFeatureData, store_path)

#     return redirect(url_for('index'))

# if __name__ == '__main__':
#     app.run(debug=True)
from flask import Flask, request, render_template, redirect, url_for, send_from_directory, send_file, jsonify
import os
import numpy as np
import plotly.graph_objects as go
import zipfile
from OCC.Core.STEPControl import STEPControl_Reader
from OCC.Core.BRepMesh import BRepMesh_IncrementalMesh
from OCC.Core.Bnd import Bnd_Box
from OCC.Core.BRepBndLib import brepbndlib_Add
from OCC.Core.TopExp import TopExp_Explorer
from OCC.Core.TopAbs import TopAbs_FACE, TopAbs_EDGE

# Importing from gen_htp.py
from gen_htp import Gen_HTP, GeneratePoints, PrintPointsToFile, PrintHeightsToFile

app = Flask(__name__)

# Define where uploaded STEP files will be stored
UPLOAD_FOLDER = 'uploads'
OUTPUT_FOLDER = 'output'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['OUTPUT_FOLDER'] = OUTPUT_FOLDER

# Allowed file extensions
ALLOWED_EXTENSIONS = {'step', 'stp'}

# Ensure the folders exist
for folder in [UPLOAD_FOLDER, OUTPUT_FOLDER]:
    if not os.path.exists(folder):
        os.makedirs(folder)

# Helper function to check file extension
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

# Route for the homepage
@app.route('/')
def index():
    return render_template('index.html')

# Route to handle file upload
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return 'No file part'
    file = request.files['file']
    if file.filename == '':
        return 'No selected file'
    
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)
        
        # After saving, process the file
        result = process_step_file(file_path, filename)
        
        return jsonify(result)
    return 'Invalid file type'

# Process the uploaded STEP file and generate toolpaths
def process_step_file(file_path, filename):
    # Read STEP file
    step_reader = STEPControl_Reader()
    step_reader.ReadFile(file_path)
    step_reader.TransferRoots()
    shape = step_reader.OneShape()

    # Mesh the shape
    BRepMesh_IncrementalMesh(shape, 0.1)

    # Get bounding box of the shape
    bbox = Bnd_Box()
    brepbndlib_Add(shape, bbox)
    xmin, ymin, zmin, xmax, ymax, zmax = bbox.Get()

    # Slice parameters
    slice_height = 0.2  # Set slice height
    segm_length = 10.0  # Set segment length

    # Generate toolpaths
    mvFeatureData = extract_features(shape)  # Extract feature data
    store_path = app.config['OUTPUT_FOLDER']

    # Call Gen_HTP to generate contours and heights
    Gen_HTP(slice_height, segm_length, mvFeatureData, store_path)

    # Create response
    response = {
        "message": "STEP file processed successfully",
        "bounding_box": [xmin, ymin, zmin, xmax, ymax, zmax],
        "filename": filename
    }
    return response

# Function to extract features from the shape
def extract_features(shape):
    features = []

    # Extract faces
    explorer = TopExp_Explorer(shape, TopAbs_FACE)
    while explorer.More():
        face = explorer.Current()
        # Get some properties (like area, vertices, etc.)
        features.append(face)
        explorer.Next()

    # Extract edges (if necessary)
    explorer_edge = TopExp_Explorer(shape, TopAbs_EDGE)
    while explorer_edge.More():
        edge = explorer_edge.Current()
        features.append(edge)
        explorer_edge.Next()

    return features

# Route to visualize the result
@app.route('/visualize/<filename>')
def visualize(filename):
    output_dir = app.config['OUTPUT_FOLDER']
    
    # Load contours or points generated by Gen_HTP
    points_file = os.path.join(output_dir, 'points.txt')  # Assuming points are saved as 'points.txt'
    heights_file = os.path.join(output_dir, 'heights.txt')  # Assuming heights are saved as 'heights.txt'

    if not os.path.exists(points_file):
        return "No points file found"

    # Load points from file
    points = np.loadtxt(points_file)
    x, y, z = points[:, 0], points[:, 1], points[:, 2]

    # Create a 3D plot with the toolpaths
    fig = go.Figure(data=[
        go.Scatter3d(x=x, y=y, z=z, mode='lines', line=dict(width=2, color='blue'))
    ])
    
    fig.update_layout(title="Generated Toolpaths", scene=dict(
        xaxis_title='X',
        yaxis_title='Y',
        zaxis_title='Z'
    ))

    graph_div = fig.to_html(full_html=False)
    
    return render_template('visualize.html', graph_div=graph_div)

# Route to download the output ZIP file
@app.route('/download/<path:filename>', methods=['GET', 'POST'])
def download(filename):
    uploads = os.path.join(app.root_path, app.config['UPLOAD_FOLDER'])
    return send_from_directory(directory=uploads, path=filename)

# Function to compress output files into a ZIP for download
def zip_folder(folder_path, output_zip):
    with zipfile.ZipFile(output_zip, 'w') as zipf:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                zipf.write(os.path.join(root, file), os.path.relpath(os.path.join(root, file), folder_path))

# Route to generate and download output ZIP
@app.route('/download_output/<string:step_filename>')
def download_output(step_filename):
    step_file_path = os.path.join(app.config['UPLOAD_FOLDER'], step_filename)
    
    if not os.path.exists(step_file_path):
        return 'File not found'
    
    output_dir = app.config['OUTPUT_FOLDER']  # Output directory from Gen_HTP
    zip_output_path = os.path.join(app.config['UPLOAD_FOLDER'], 'htp_output.zip')
    
    # Create the ZIP file of the output
    zip_folder(output_dir, zip_output_path)
    
    return send_file(zip_output_path, as_attachment=True)

if __name__ == '__main__':
    app.run(debug=True)
